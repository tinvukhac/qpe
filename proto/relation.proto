syntax = "proto2";

package qpe.proto;

option java_package = "edu.ucr.cs.qpe";
option java_outer_classname = "RelationProtos";

message Relation {
    enum OpCode {
        /*JOIN = 0;
        MAPJOIN = 1;
        EXTRACT = 2;
        FILTER = 3;
        FORWARD = 4;
        GROUPBY = 5;
        LIMIT = 6;
        SCRIPT = 7;
        SELECT = 8;
        TABLESCAN = 9;
        FILESINK = 10;
        REDUCESINK = 11;
        UNION = 12;
        UDTF = 13;
        LATERALVIEWJOIN = 14;
        LATERALVIEWFORWARD = 15;
        HASHTABLESINK = 16;
        HASHTABLEDUMMY = 17;
        PTF = 18;
        MUX = 19;
        DEMUX = 20;
        EVENT = 21;
        ORCFILEMERGE = 22;
        RCFILEMERGE = 23;
        MERGEJOIN = 24;
        SPARKPRUNINGSINK = 25;
        NONE = 26; */ // No operator for leaf nodes of graph, so we can handle cases uniformly.
        AbstractConverter = 0;
		AbstractRelNode = 1;
		Aggregate = 2;
		AltTraitConverter = 3;
		BindableAggregate = 4;
		BindableFilter = 5;
		BindableJoin = 6;
		BindableProject = 7;
		BindableRel = 8;
		BindableSort = 9;
		BindableTableScan = 10;
		BindableUnion = 11;
		BindableValues = 12;
		BindableWindow = 13;
		BiRel = 14;
		BridgeRel = 15;
		Calc = 16;
		Chi = 17;
		Collect = 18;
		Converter = 19;
		ConverterImpl = 20;
		Correlate = 21;
		Delta = 22;
		ElasticsearchFilter = 23;
		ElasticsearchProject = 24;
		ElasticsearchRel = 25;
		ElasticsearchSort = 26;
		ElasticsearchTableScan = 27;
		ElasticsearchToEnumerableConverter = 28;
		EnumerableAggregate = 29;
		EnumerableBindable = 30;
		EnumerableCalc = 31;
		EnumerableCollect = 32;
		EnumerableCorrelate = 33;
		EnumerableFilter = 34;
		EnumerableInterpretable = 35;
		EnumerableInterpreter = 36;
		EnumerableIntersect = 37;
		EnumerableJoin = 38;
		EnumerableLimit = 39;
		EnumerableMergeJoin = 40;
		EnumerableMinus = 41;
		EnumerableProject = 42;
		EnumerableRel = 43;
		EnumerableSemiJoin = 44;
		EnumerableSort = 45;
		EnumerableTableFunctionScan = 46;
		EnumerableTableModify = 47;
		EnumerableTableScan = 48;
		EnumerableThetaJoin = 49;
		EnumerableUncollect = 50;
		EnumerableUnion = 51;
		EnumerableValues = 52;
		EnumerableWindow = 53;
		EquiJoin = 54;
		Exchange = 55;
		Filter = 56;
		FooRel = 57;
		HepRelVertex = 58;
		IntermediateNode = 59;
		InterpretableConverter = 60;
		InterpretableRel = 61;
		Intersect = 62;
		IterMergedRel = 63;
		IterSingleRel = 64;
		JdbcAggregate = 65;
		JdbcCalc = 66;
		JdbcFilter = 67;
		JdbcIntersect = 68;
		JdbcJoin = 69;
		JdbcMinus = 70;
		JdbcProject = 71;
		JdbcRel = 72;
		JdbcSort = 73;
		JdbcTableModify = 74;
		JdbcTableScan = 75;
		JdbcToEnumerableConverter = 76;
		JdbcUnion = 77;
		JdbcValues = 78;
		Join = 79;
		LeafRel = 80;
		LogicalAggregate = 81;
		LogicalCalc = 82;
		LogicalChi = 83;
		LogicalCorrelate = 84;
		LogicalDelta = 85;
		LogicalExchange = 86;
		LogicalFilter = 87;
		LogicalIntersect = 88;
		LogicalJoin = 89;
		LogicalMatch = 90;
		LogicalMinus = 91;
		LogicalProject = 92;
		LogicalSort = 93;
		LogicalTableFunctionScan = 94;
		LogicalTableModify = 95;
		LogicalTableScan = 96;
		LogicalUnion = 97;
		LogicalValues = 98;
		LogicalWindow = 99;
		Match = 100;
		Minus = 101;
		MockJdbcTableScan = 102;
		MultiJoin = 103;
		MyRel = 104;
		NoneConverter = 105;
		NoneLeafRel = 106;
		NoneSingleRel = 107;
		Phys = 108;
		PhysAgg = 109;
		PhysicalSort = 110;
		PhysLeafRel = 111;
		PhysProj = 112;
		PhysSingleRel = 113;
		PhysSort = 114;
		PhysTable = 115;
		PhysToIteratorConverter = 116;
		Project = 117;
		RandomSingleRel = 118;
		RelSubset = 119;
		RootSingleRel = 120;
		Sample = 121;
		SelfFlatteningRel = 122;
		SemiJoin = 123;
		SetOp = 124;
		SingleRel = 125;
		SingletonLeafRel = 126;
		Sort = 127;
		SortExchange = 128;
		StarTableScan = 129;
		TableFunctionScan = 130;
		TableModify = 131;
		TableScan = 132;
		TestLeafRel = 133;
		TestSingleRel = 134;
		Uncollect = 135;
		Union = 136;
		Values = 137;
		Window = 138;
		NONE = 139;
    }

    message CumulativeCost {
        optional double rows = 1;
        optional double cpu = 2;
        optional double io = 3;
    }

    optional OpCode op = 1;
    //optional Relation relations = 2;
    repeated Relation relations = 2;
    optional double rowCount = 3;
    optional CumulativeCost cumulativeCost = 4;
    optional int32 result = 5;
}
